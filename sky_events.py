#!/usr/bin/env python3

"""
Sky Events Notifier - Starlace Build (Piece 1)
Goal Today: a tiny CLI that prints a pastel banner and echoes your inputs.
"""

from __future__ import annotations
import argparse 
import datetime as dt 
from dateutil import tz
from colorama import init as color_init, Fore, Style
import requests
from ics import Calendar
from ics import Calendar, Event
import pytz
import os
from pathlib import Path
from dotenv import load_dotenv

# toml support, older versions use tomli
try: 
    import tomllib
except Exception:
    tomllib = None
    
load_dotenv()

# --- Windows notifications (winotify only) ---
try:
    from winotify import Notification
    def notify(title: str, body: str):
        n = Notification(app_id="SkyEvents",
                        title=title,
                        msg=body,
                        duration="short").show()
except Exception:
    # Fallback: no-op if  winotify isnt avaliable
    def notify(title: str, body: str):
        pass

N2YO_BASE = "https://api.n2yo.com/rest/v1/satellite/visualpasses"
ISS_NORAD = 25544

# --- Settings: adjust if you ever move timezones ---
DEFAULT_TZ = tz.gettz("America/New_York")
# Source In-The-Sky iCal feed of astronomy events
IN_THE_SKY_ICS = "https://in-the-sky.org/newscalyear_ical.php?maxdiff=7&year={year}"

KEYWORDS = (
    "meteor shower",
    "eclipse"      #solar or lunar
)

def now_local() -> dt.datetime:
    """Timezone aware 'now' so our printing is always correct."""
    return dt.datetime.now(tz=DEFAULT_TZ)

def banner(title: str) -> None:
    """Soft-but-bold console banner."""
    color_init(autoreset=True)
    print(Style.BRIGHT + Fore.MAGENTA + f"\n* {title} *\n" + Style.RESET_ALL)

def fetch_astronomy_ics(year: int) -> Calendar:
    """Download the astronomy  iCal feed for the given year."""
    url = IN_THE_SKY_ICS.format(year=year)
    r = requests.get(url, timeout=30)
    r.raise_for_status()
    return Calendar(r.text)

def extract_meteors_eclipses(cal: Calendar, horizon_days: int):
    """Filter the calendar for meteors & eclipses within horizon_days""" 
    cutoff = now_local() + dt.timedelta(days=horizon_days)
    out = []
    for ev in cal.events:
        name = (ev.name or "").strip()
        lname = name.lower()
        if not any(k in lname for k in KEYWORDS):
            continue

        start = ev.begin.datetime if ev.begin else None
        if not start:
            continue

        start = start.astimezone(DEFAULT_TZ)
        if start < now_local() or start > cutoff:
            continue
        etype = "Meteor Shower"  if "meteor shower" in lname else ("Eclipse" if "eclipse" in lname else "Event")
        out.append({
            "type": etype,
            "name": name,
            "start": start,
            "source": "In-The-Sky iCal"

        })
    out.sort(key=lambda e: e["start"])
    return out

def fetch_iss_passes(lat: float, lon: float, alt_m: int, days: int, min_elev: int = 10):
    """
    Get visible ISS passes for your location using N2YO.
    min_elev filters out low, meh passes (30 degrees = decent).
    Returns a list of dicts sorted by start time. 
    """
    api_key = os.environ.get("N2YO_API_KEY")
    if not api_key:
        return[] # no key set; skip quietly
    
    url = f"{N2YO_BASE}/{ISS_NORAD}/{lat:.4f}/{lon:.4f}/{alt_m}/{days}/{min_elev}/&apiKey={api_key}"
    try: 
        r = requests.get(url, timeout=30)
        r.raise_for_status()
        data = r.json()
    except Exception:
        return[]
    
    passes = data.get("passes", []) or []
    out = []
    for p in passes:
        start_utc = dt.datetime.fromtimestamp(p.get("startUTC", 0), tz=dt.timezone.utc)
        end_utc = dt.datetime.fromtimestamp(p.get("endUTC", 0), tz=dt.timezone.utc)
        start = start_utc.astimezone(DEFAULT_TZ)
        end = end_utc.astimezone(DEFAULT_TZ)
        max_el = int(p.get("maxEl", 0))
        mag = p.get("mag", None)

        out.append({
            "type": "ISS Pass",
            "name": f"ISS visible pass (max elev ~{max_el}Â°)",
            "start": start,
            "end": end,
            "mag": mag,
            "source": "N2YO"
        })

    out.sort(key=lambda e: e["start"])
    return out

def export_ics (events, path_str: str):
    """
    Writes a merged list of events to an .ics file your phone can subscribe to .
    Expects each item to have: name, start (datetime), and optional end, type, source.
    """

    path = Path(path_str)
    path.parent.mkdir(parents=True, exist_ok=True)

    cal = Caendar()
    for e in events:
        ev = Events()
        title_type = e.get("type", "").strip()
        ev.name = f"{title_type}: {e['name']}" if title_type else e["name"]
        ev.begin = e["start"]    # timezone-aware datetime
        if e.get("end"):
            ev.end = e["end"]
        # tasteful description
        src = e.get("source", "Sky_Events")
        ev.description = f"From {src}. Generated by SkyEvents."
        cal.events.add(ev)

    # Write atomically
    tmp = path.with_suffix(".tmp")
    with tmp.open("w", encoding="utf-8") as f:
        f.writelines(cal.serialize_iter())
    tmp.replace(path)
    print(f"[ics] Wrote {path.resolve()}")

def load_config(path: str = "config.toml") -> dict:
    p = Path(path)
    if not p.exists():
        return {}
    
    raw = p.read_bytes()

    if tomllib:
        return tomllib.loads(raw.decode("utf-8"))
    else: 
        import tomli
        return tomli.loads(raw.decode("utf-8"))

def build_newsletter_text(all_events, iss_events, args) -> str:
    now = now_local()

    combined = (all_events + iss_events)
    combined.sort(key=lambda e: e["start"])
    highlights = combined[:3]

    def fmt_line(e):
        when = e["start"].strftime("%a %b %d, %I:%M %p %Z")
        if e.get("end"):
            end = e["end"].strftime("%I:%M %p %Z")
            when = f"{when} -> {end}"
        return f"- {e.get('type','Event')}: {e['name']} - {when}"
    
    lines = []
    lines.append("SKY EVENTS DISPATCH")
    lines.append("=" * 60)
    lines.append(f"Generated: {now.strftime('%a %b %d, %Y * %I:%M %p %Z')}")
    lines.append(f"Location:   lat={args.lat} lon={args.lon} alt={args.alt}m")
    lines.append(f"Horizon:     {args.days} days")
    lines.append("")

    lines.append("HIGHLIGHTS (Top 3)")
    if highlights:
        for e in highlights:
            lines.append(fmt_line(e))
    else:
        lines.append("- No events found in range.")
    lines.append("")

    lines.append("METEORS + ECLIPSES")
    if all_events:
        for e in all_events:
            lines.append(fmt_line(e))
    else:
        lines.append("- None found.")
    lines.append("")

    lines.append("ISS PASSES")
    if iss_events:
        for e in iss_events:
            start = e["start"].strftime("%a %b %d, %I:%M %p %Z")
            end = e["end"].strftime("%I:M %p %Z")
            mag = f" (mag {e['mag']})" if e.get("mag") is not None else ""
            lines.append(f"- {e['name']} - {start} -> {end}{mag}")
    else:
        lines.append("- None found or N2YO_API_KEY not set.")
    lines.append("")

    lines.append("SKY NOTE")
    lines.append("- Step outside 5 minutes early. No bright screens.")
    lines.append("- Avoid bright screens; use red lights if possible")
    lines.append("")
    lines.append("Generated by Sky Events Notifier")
    return "\n".join(lines)

def save_text(path: str, text: str):
    p = Path(path)
    p.parent.mkdir(parents=True, exist_ok=True)
    p.write_text(text, encoding="utf-8")
    print(f"[report] Saved to {p.resolve()}")
        
def main():
    # 1) CLI: we keep it explicit-no magic guesses. 
    ap = argparse.ArgumentParser(description="Sky Events - Starlace Build")
    ap.add_argument("--config", default="config.toml", help="Path to config.toml")
    ap.add_argument("--lat", type=float, default=None, help="Latitude (decimal degrees)")
    ap.add_argument("--lon", type=float, default=None, help="Longitude (decimal degrees)")
    ap.add_argument("--alt", type=int, default=None, help="Altitude in meters (rough is fine)")
    ap.add_argument("--days", type=int, default=None, help="Lookahead horizon in days")
    ap.add_argument("--notify", action="store_true",
                    help="Show Windows toast notifications for the next upcoming events")
    ap.add_argument("--export-ics", metavar="PATH",
                    help="Write upcoming events to an iCalendar file (e.g. sky_events.ics)")
    ap.add_argument("--newsletter", action="store_true",
                    help="Use newsletter-style formatting for the report")
    ap.add_argument("--report", action="store_true",
                    help="Print the report to the terminal")
    ap.add_argument("--save-report", metavar="PATH",
                    help="Save the report to a file (.txt or .md)")
    args = ap.parse_args()

    cfg = load_config(args.config)

    loc = cfg.get("location", {})
    defs = cfg.get("defaults", {})

    # Apply defaults from configs if CLI was not provides
    args.lat = args.lat if args.lat is not None else loc.get("lat")
    args.lon = args.lon if args.lon is not None else loc.get("lon")
    args.alt = args.alt if args.alt is not None else loc.get("alt", 50)
    args.days = args.days if args.days is not None else defs.get("days", 14)

    # notify is a flag; only enable from config
    if not args.notify:
        args.notify = bool(defs.get("notify", False))

    if args.lat is None or args.lon is None:
        raise SystemExit("Missing lat/lon. Provide --lat/--lon or set them in config.toml under [location].")


    # 2) Vibes + echo
    banner("Sky Events - Hello SpaceJunkie")
    print(Fore.CYAN + "Your settings:" + Style.RESET_ALL)
    print(f"- Latitude:     {args.lat}")
    print(f"- Longitude:    {args.lon}")
    print(f"- Altitude:     {args.alt} m")
    print(f"- Horizon:      {args.days} days")
    print(f"- Now:          {now_local().strftime('%a %b %d, %I:%M %p %Z')}")

    # --- Astrononmy events ---
    years = {now_local().year, (now_local() + dt.timedelta(days=args.days)).year}
    all_events = []
    for y in sorted(years):
        try:
            cal = fetch_astronomy_ics(y)
            all_events += extract_meteors_eclipses(cal, args.days)
        except Exception as ex:
            print(f"[Error fetching {y} feeds: {ex}]")

    print("\nAstronomy events coming up:")
    if all_events:
        for e in all_events:
            when = e["start"].strftime("%a %b %d, %I:%M %p %Z")
            print(f"- {e['type']}: {e['name']} - {when}")
    else:
        print("- None found in range")

    # --- ISS Passes ---
    iss_events = fetch_iss_passes(args.lat, args.lon, args.alt, args.days)
    print("\nISS passes:")
    if iss_events:
        for e in iss_events:
            start = e["start"].strftime("%a %b %d, %I:%M %p %Z")
            end = e["end"].strftime("%I:%M %p %Z")
            extra = f" (mag {e['mag']})" if e.get('mag') is not None else ""
            print(f"- {e['name']} - {start} -> {end}{extra}")
    else:
        print("- None found or N2YO_API_KEY not set.")

     # --- Optional notifications ---
    if args.notify:
        upcoming = (all_events + iss_events)
        upcoming.sort(key=lambda e: e["start"])
        for e in upcoming[:2]:
            title = "Sky Event"
            when = e["start"].strftime("%a %b %d, %I:%M %p %Z")
            body = f"{e['type']}: {e['name']} at {when}"
            # debug print so you can see its being calles
            print(f"[notify] {body}")
            notify(title, body)

    # Merge and sort for any downstream actions (notify/export/etc.)
    combined = (all_events + iss_events)
    combined.sort(key=lambda e: e["start"])

    # Report/Newsletter mode
    if args.report or args.save.report:
        if args.newsletter:
            report_text = build_newsletter_text(all_events, iss_events, args)
        else:
            report_text = build_report_text(all_events, iss_events. args)
        if args.report:
            print("\n" + report_text)
        if args.save_report:
            save_text(args.save_report, report_text)

    # --- Export .ics if asked ---
    if args.export_ics:
        export_ics(combined, args.export_ics)

if __name__ == "__main__":
    raise SystemExit(main()) 




